<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibTaomee: libtaomee/list.hæ–‡ä»¶å‚è€ƒ</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- åˆ¶ä½œè€… Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>é¦–é¡µ</span></a></li>
      <li><a href="annotated.html"><span>ç±»</span></a></li>
      <li class="current"><a href="files.html"><span>æ–‡ä»¶</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>libtaomee/list.hæ–‡ä»¶å‚è€ƒ</h1>ä»å†…æ ¸ä»£ç é‡ŒæŠ½å–å‡ºæ¥çš„ä¾µå…¥å¼é“¾è¡¨æ“ä½œå‡½æ•°/å®ã€‚<br>
 Simple doubly linked list implementation.<br>
 <a href="#_details">æ›´å¤š...</a>
<p>

<p>
<div class="dynheader">
æ­¤å›¾å±•ç¤ºç›´æ¥æˆ–é—´æ¥åŒ…å«è¯¥æ–‡ä»¶çš„æ–‡ä»¶ï¼š</div>
<div class="dynsection">
<p><center><img src="list_8h__dep__incl.png" border="0" usemap="#libtaomee/list.hdep_map" alt=""></center>
<map name="libtaomee/list.hdep_map">
<area shape="rect" href="timer_8h.html" title="å®šæ—¶å™¨å‡½æ•°ï¼Œæœ‰ç§’çº§å’Œæ¯«ç§’çº§ä¸¤ç§ç²¾åº¦çš„æ¥å£ã€‚ç”¨äºè®¾å®šæŸä¸€æ—¶åˆ»è°ƒç”¨æŸä¸ªå..." alt="" coords="5,80,125,107"></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>ç»„åˆç±»å‹</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlist__head.html">list_head</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">é“¾è¡¨å¤´ç»“ç‚¹ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿç”¨æ¥è¿æ¥æ¯ä¸ªå­ç»“ç‚¹ã€‚  <a href="structlist__head.html#_details">æ›´å¤š...</a><br></td></tr>
<tr><td colspan="2"><br><h2>å®å®šä¹‰</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#0ffe9d28c36d7b018a9cfae33bae45c0">INIT_LIST_HEAD</a>(ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">åˆå§‹åŒ–å¤´èŠ‚ç‚¹ã€‚åˆå§‹åŒ–åï¼Œptr-&gt;nextå’Œptr-&gt;prevéƒ½æŒ‡å‘ptræœ¬èº«ã€‚  <a href="#0ffe9d28c36d7b018a9cfae33bae45c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#26c976b7f654e70df318c1843e5094de">list_entry</a>(ptr, type, member)&nbsp;&nbsp;&nbsp;((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the struct for this entry  <a href="#26c976b7f654e70df318c1843e5094de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#b8b24e6660ab3760c923e4b4db3fa502">list_for_each</a>(pos, head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterate over a list  <a href="#b8b24e6660ab3760c923e4b4db3fa502"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#19fc06b83f3502a83ce566b8887e6aec">list_for_each_prev</a>(pos, head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterate over a list backwards  <a href="#19fc06b83f3502a83ce566b8887e6aec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#9e4b9328744994b9d3878f5dad75c09f">list_for_each_safe</a>(pos, n, head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterate over a list safe against removal of list entry  <a href="#9e4b9328744994b9d3878f5dad75c09f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#9b782fefb5ab71ce9762182e45a615e1">list_for_each_entry</a>(pos, head, member)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterate over list of given type  <a href="#9b782fefb5ab71ce9762182e45a615e1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>ç±»å‹å®šä¹‰</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2dfa4d13dfe6af1e2b62535310a34db1"></a><!-- doxytag: member="list.h::list_head_t" ref="2dfa4d13dfe6af1e2b62535310a34db1" args="" -->
typedef struct <a class="el" href="structlist__head.html">list_head</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#2dfa4d13dfe6af1e2b62535310a34db1">list_head_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a typedef <br></td></tr>
<tr><td colspan="2"><br><h2>å‡½æ•°</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a680b346eddc4fe39b67544c708b6c9d">list_add</a> (struct <a class="el" href="structlist__head.html">list_head</a> *new_entry, struct <a class="el" href="structlist__head.html">list_head</a> *head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add a new entry<br>
 Insert a new entry after the specified head. This is good for implementing stacks.  <a href="#a680b346eddc4fe39b67544c708b6c9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#76d81635004d29437717424d8e9c7884">list_add_tail</a> (struct <a class="el" href="structlist__head.html">list_head</a> *new_entry, struct <a class="el" href="structlist__head.html">list_head</a> *head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add a new entry<br>
 Insert a new entry before the specified head. This is useful for implementing queues.  <a href="#76d81635004d29437717424d8e9c7884"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#b1708206f0f7e0a56550b35372203ba5">list_del</a> (struct <a class="el" href="structlist__head.html">list_head</a> *entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">deletes entry from list.<br>
  <a href="#b1708206f0f7e0a56550b35372203ba5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#e1cde0f50b85945cfff23be4fc1586f4">list_del_init</a> (struct <a class="el" href="structlist__head.html">list_head</a> *entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">deletes entry from list and reinitialize it.  <a href="#e1cde0f50b85945cfff23be4fc1586f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ee8df43e41969c2272acfd6ed6e75d4c">list_move</a> (struct <a class="el" href="structlist__head.html">list_head</a> *list, struct <a class="el" href="structlist__head.html">list_head</a> *head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete from one list and add as another's head  <a href="#ee8df43e41969c2272acfd6ed6e75d4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#1c5ac6a6b04a03f5782e818daacf96e9">list_move_tail</a> (struct <a class="el" href="structlist__head.html">list_head</a> *list, struct <a class="el" href="structlist__head.html">list_head</a> *head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete from one list and add as another's tail  <a href="#1c5ac6a6b04a03f5782e818daacf96e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#0fce12be81e8f2677b3a272fee1652ac">list_empty</a> (struct <a class="el" href="structlist__head.html">list_head</a> *head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tests whether a list is empty  <a href="#0fce12be81e8f2677b3a272fee1652ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#2c4399cfbde5e5d5eddf2e13c97bd5d5">list_splice</a> (struct <a class="el" href="structlist__head.html">list_head</a> *list, struct <a class="el" href="structlist__head.html">list_head</a> *head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">join two lists  <a href="#2c4399cfbde5e5d5eddf2e13c97bd5d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#948b15519bb72e3d42f3e56975580d30">list_splice_init</a> (struct <a class="el" href="structlist__head.html">list_head</a> *list, struct <a class="el" href="structlist__head.html">list_head</a> *head)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">join two lists and reinitialise the emptied list.  <a href="#948b15519bb72e3d42f3e56975580d30"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>è¯¦ç»†æè¿°</h2>
ä»å†…æ ¸ä»£ç é‡ŒæŠ½å–å‡ºæ¥çš„ä¾µå…¥å¼é“¾è¡¨æ“ä½œå‡½æ•°/å®ã€‚<br>
 Simple doubly linked list implementation.<br>
 
<p>
============================================================<p>
compiler gcc4.1.2 platform Linux<p>
copyright: TaoMee, Inc. ShangHai CN. All rights reserved.<p>
============================================================ <hr><h2>å®å®šä¹‰æ–‡æ¡£</h2>
<a class="anchor" name="0ffe9d28c36d7b018a9cfae33bae45c0"></a><!-- doxytag: member="list.h::INIT_LIST_HEAD" ref="0ffe9d28c36d7b018a9cfae33bae45c0" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INIT_LIST_HEAD          </td>
          <td>(</td>
          <td class="paramtype">ptr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>å€¼:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
        (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \
} <span class="keywordflow">while</span> (0)
</pre></div>åˆå§‹åŒ–å¤´èŠ‚ç‚¹ã€‚åˆå§‹åŒ–åï¼Œptr-&gt;nextå’Œptr-&gt;prevéƒ½æŒ‡å‘ptræœ¬èº«ã€‚ 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>å¤´èŠ‚ç‚¹æŒ‡é’ˆ </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="26c976b7f654e70df318c1843e5094de"></a><!-- doxytag: member="list.h::list_entry" ref="26c976b7f654e70df318c1843e5094de" args="(ptr, type, member)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define list_entry          </td>
          <td>(</td>
          <td class="paramtype">ptr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">member&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the struct for this entry 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the &amp;struct <a class="el" href="structlist__head.html" title="é“¾è¡¨å¤´ç»“ç‚¹ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿç”¨æ¥è¿æ¥æ¯ä¸ªå­ç»“ç‚¹ã€‚">list_head</a> pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type of the struct this is embedded in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>member</em>&nbsp;</td><td>the name of the list_struct within the struct. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b8b24e6660ab3760c923e4b4db3fa502"></a><!-- doxytag: member="list.h::list_for_each" ref="b8b24e6660ab3760c923e4b4db3fa502" args="(pos, head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define list_for_each          </td>
          <td>(</td>
          <td class="paramtype">pos,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">head&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>å€¼:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (pos = (head)-&gt;next, __builtin_prefetch(pos-&gt;next,0,1); \
                         pos != (head); \
                         pos = pos-&gt;next, __builtin_prefetch(pos-&gt;next,0,1))
</pre></div>iterate over a list 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the &amp;struct <a class="el" href="structlist__head.html" title="é“¾è¡¨å¤´ç»“ç‚¹ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿç”¨æ¥è¿æ¥æ¯ä¸ªå­ç»“ç‚¹ã€‚">list_head</a> to use as a loop counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the head for your list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9b782fefb5ab71ce9762182e45a615e1"></a><!-- doxytag: member="list.h::list_for_each_entry" ref="9b782fefb5ab71ce9762182e45a615e1" args="(pos, head, member)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define list_for_each_entry          </td>
          <td>(</td>
          <td class="paramtype">pos,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">head,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">member&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>å€¼:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (pos = <a class="code" href="list_8h.html#26c976b7f654e70df318c1843e5094de" title="get the struct for this entry">list_entry</a>((head)-&gt;next, typeof(*pos), member),      \
                     __builtin_prefetch(pos-&gt;member.next,0,1);                  \
                     &amp;pos-&gt;member != (head);                                    \
                     pos = <a class="code" href="list_8h.html#26c976b7f654e70df318c1843e5094de" title="get the struct for this entry">list_entry</a>(pos-&gt;member.next, typeof(*pos), member),  \
                     __builtin_prefetch(pos-&gt;member.next,0,1))
</pre></div>iterate over list of given type 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the type * to use as a loop counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the head for your list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>member</em>&nbsp;</td><td>the name of the list_struct within the struct. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19fc06b83f3502a83ce566b8887e6aec"></a><!-- doxytag: member="list.h::list_for_each_prev" ref="19fc06b83f3502a83ce566b8887e6aec" args="(pos, head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define list_for_each_prev          </td>
          <td>(</td>
          <td class="paramtype">pos,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">head&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>å€¼:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (pos = (head)-&gt;prev, __builtin_prefetch(pos-&gt;prev,0,1); \
         pos != (head); \
         pos = pos-&gt;prev, __builtin_prefetch(pos-&gt;prev,0,1))
</pre></div>iterate over a list backwards 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the &amp;struct <a class="el" href="structlist__head.html" title="é“¾è¡¨å¤´ç»“ç‚¹ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿç”¨æ¥è¿æ¥æ¯ä¸ªå­ç»“ç‚¹ã€‚">list_head</a> to use as a loop counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the head for your list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9e4b9328744994b9d3878f5dad75c09f"></a><!-- doxytag: member="list.h::list_for_each_safe" ref="9e4b9328744994b9d3878f5dad75c09f" args="(pos, n, head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define list_for_each_safe          </td>
          <td>(</td>
          <td class="paramtype">pos,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">n,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">head&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>å€¼:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \
                pos = n, n = pos-&gt;next)
</pre></div>iterate over a list safe against removal of list entry 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>the &amp;struct <a class="el" href="structlist__head.html" title="é“¾è¡¨å¤´ç»“ç‚¹ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿç”¨æ¥è¿æ¥æ¯ä¸ªå­ç»“ç‚¹ã€‚">list_head</a> to use as a loop counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>nother &amp;struct <a class="el" href="structlist__head.html" title="é“¾è¡¨å¤´ç»“ç‚¹ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿç”¨æ¥è¿æ¥æ¯ä¸ªå­ç»“ç‚¹ã€‚">list_head</a> to use as temporary storage </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the head for your list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>å‡½æ•°æ–‡æ¡£</h2>
<a class="anchor" name="a680b346eddc4fe39b67544c708b6c9d"></a><!-- doxytag: member="list.h::list_add" ref="a680b346eddc4fe39b67544c708b6c9d" args="(struct list_head *new_entry, struct list_head *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_add           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>new_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add a new entry<br>
 Insert a new entry after the specified head. This is good for implementing stacks. 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_entry</em>&nbsp;</td><td>new entry to be added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>list head to add it after </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="76d81635004d29437717424d8e9c7884"></a><!-- doxytag: member="list.h::list_add_tail" ref="76d81635004d29437717424d8e9c7884" args="(struct list_head *new_entry, struct list_head *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_add_tail           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>new_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
add a new entry<br>
 Insert a new entry before the specified head. This is useful for implementing queues. 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_entry</em>&nbsp;</td><td>new entry to be added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>list head to add it before </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b1708206f0f7e0a56550b35372203ba5"></a><!-- doxytag: member="list.h::list_del" ref="b1708206f0f7e0a56550b35372203ba5" args="(struct list_head *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_del           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
deletes entry from list.<br>
 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>the element to delete from the list. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>æ³¨è§£:</b></dt><dd>list_empty on entry does not return true after this, the entry is in an undefined state. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e1cde0f50b85945cfff23be4fc1586f4"></a><!-- doxytag: member="list.h::list_del_init" ref="e1cde0f50b85945cfff23be4fc1586f4" args="(struct list_head *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_del_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
deletes entry from list and reinitialize it. 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>the element to delete from the list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0fce12be81e8f2677b3a272fee1652ac"></a><!-- doxytag: member="list.h::list_empty" ref="0fce12be81e8f2677b3a272fee1652ac" args="(struct list_head *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int list_empty           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
tests whether a list is empty 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the list to test. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ee8df43e41969c2272acfd6ed6e75d4c"></a><!-- doxytag: member="list.h::list_move" ref="ee8df43e41969c2272acfd6ed6e75d4c" args="(struct list_head *list, struct list_head *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_move           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
delete from one list and add as another's head 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the entry to move </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the head that will precede our entry </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1c5ac6a6b04a03f5782e818daacf96e9"></a><!-- doxytag: member="list.h::list_move_tail" ref="1c5ac6a6b04a03f5782e818daacf96e9" args="(struct list_head *list, struct list_head *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_move_tail           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
delete from one list and add as another's tail 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the entry to move </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the head that will follow our entry </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2c4399cfbde5e5d5eddf2e13c97bd5d5"></a><!-- doxytag: member="list.h::list_splice" ref="2c4399cfbde5e5d5eddf2e13c97bd5d5" args="(struct list_head *list, struct list_head *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_splice           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
join two lists 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the new list to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the place to add it in the first list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="948b15519bb72e3d42f3e56975580d30"></a><!-- doxytag: member="list.h::list_splice_init" ref="948b15519bb72e3d42f3e56975580d30" args="(struct list_head *list, struct list_head *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void list_splice_init           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__head.html">list_head</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
join two lists and reinitialise the emptied list. 
<p>
<dl compact><dt><b>å‚æ•°:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the new list to add. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>the place to add it in the first list.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>æ³¨è§£:</b></dt><dd>'list' is reinitialised </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated at Thu Nov 26 17:06:52 2009 for LibTaomee by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
